##  线性结构

### 1. 数组

特点：

- 有索引下标
- 数组内元素类型统一
- 连续存储



#### 稀疏数组

sparse array

主要用于存储和压缩二维数组

适用于大部分值都相同的情况

记录：行、列、值



算法步骤：

1. 遍历整个数组，获得需要创建的压缩二维数组大小为sum+1
2. 创建压缩后的二维数组
3. 再次遍历，将目标位置和值填入压缩后的数组



### 2. 队列

先入先出



#### 数组实现

数据结构：

- maxSize
- front：指向队首的前一个位置
- rear：直接指向队尾



方法：

- 构造器： `front = rear = -1`
- 判断队列是否满
- 判断队列是否为空
- 入队列
- 出队列
- 队列打印



#### 数组实现（环形）

在数组实现的基础上改成环形数组（取模）



数据结构：

- maxSize
- front：指向第一个元素
- rear：指向最后一个元素的后一个（希望空出一个空间，作为约定）



方法：

- 构造器：`front =0,rear = 0`
- 判断队列是否满：`(rear + 1) mod maxSize == front` 
- 判断队列是否为空：`rear == front`
- 入队列
- 出队列
- **队列打印** ：`rear + maxSize - front) % maxSize`





#### 链表实现





### 3. 链表

#### 单向链表

- 链表是以节点的方式存储，头节点不一定存在
- 不是顺序结构，而是链式结构
- 数据结构：data+next，最后一个节点的next为null



**方法：**

- 增
  - add
  - addByOrder
- 删：删除的节点没有指针指向，会被垃圾回收机制回收
- 改查



**面试题：**

- 单链表中有效节点的个数
- 查找单链表中的倒数第k个节点
  - 方法1：先求出length，再用length-k
  - 方法2：双指针
  - 两种方式时间复杂度相同

- 单链表反转：原链表边遍历，边把节点挂到新链表上，完成反转
- 逆序打印
  - 反转后逆序打印：效率较低
  - 利用栈结构
  - 递归打印
- 合并两个有序单链表，合并之后依然有序：双指针



#### 双向链表

- 数据结构：pre+data+next



#### 环形链表

##### 单向环形链表

实例：约瑟夫问题解决

- 删除指定的节点时，需找到指定节点的上一个节点（使用双指针）



### 4. 栈

数据结构：

- 先进后出 后进先出
- 有栈底指针base和栈顶指针top



#### 数组实现

- top初始化为-1，入栈时 stack[top] = data

- 设定栈的最大容量

  

#### 链表实现

- 头插法
- 不设定最大容量



**实例：**

计算器实现

1. 中缀表达式直接运算，即”6+3*3-1“
   - 运算符的优先级：比较当前要入栈的运算符的优先级于栈顶优先级
     - 若栈为空，则直接入栈
     - 若当前要入栈的优先级更大，则直接入栈
     - 若栈顶优先级更大，则出栈并计算栈顶运算符：数栈中pop两个数，符号栈pop一个符号，将**计算结果入数栈**（每一次计算结果都要入栈），将新符号入符号栈
   - 构造完毕后，从数栈和符号栈中取出并进行运算，最后数栈中的值为最终结果



> 前缀表达式：运算符位于操作数前面，不需要判断优先级
>
> - 先求出前缀表达式
> - 从右到左扫描，遇到数字进栈，遇到字符则弹出两个数字运算
>
> 后缀表达式：运算符位于操作数后面
>
> - 先求出后缀表达式
>
>   <img src="C:\Users\12505\AppData\Roaming\Typora\typora-user-images\image-20210711120754741.png" alt="image-20210711120754741" style="zoom: 50%;" /> 
>
> - 从左到右扫描，遇到数字进栈，遇到字符则弹出两个数字运算



## 树形结构

### 1. 二叉树

以根的访问顺序做划分

左子树始终先于右子树

#### 先序遍历

#### 中序遍历

#### 后序遍历





## 图

