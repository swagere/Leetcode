##  线性结构

### 1. 数组

特点：

- 有索引下标
- 数组内元素类型统一
- 连续存储



#### 稀疏数组

sparse array

主要用于存储和压缩二维数组

适用于大部分值都相同的情况

记录：行、列、值



算法步骤：

1. 遍历整个数组，获得需要创建的压缩二维数组大小为sum+1
2. 创建压缩后的二维数组
3. 再次遍历，将目标位置和值填入压缩后的数组



### 2. 链表

#### 单向链表

- 链表是以节点的方式存储，头节点不一定存在
- 不是顺序结构，而是链式结构
- 数据结构：data+next，最后一个节点的next为null



**方法：**

- 增
  - add
  - addByOrder
- 删：删除的节点没有指针指向，会被垃圾回收机制回收
- 改查



**面试题：**

- 单链表中有效节点的个数
- 查找单链表中的倒数第k个节点
  - 方法1：先求出length，再用length-k
  - 方法2：双指针
  - 两种方式时间复杂度相同

- 单链表反转：原链表边遍历，边把节点挂到新链表上，完成反转
- 逆序打印
  - 反转后逆序打印：效率较低
  - 利用栈结构
  - 递归打印
- 合并两个有序单链表，合并之后依然有序：双指针



#### 双向链表

- 数据结构：pre+data+next



#### 环形链表

##### 单向环形链表

实例：约瑟夫问题解决

- 删除指定的节点时，需找到指定节点的上一个节点（使用双指针）



### 3. 队列

先入先出



#### 数组实现

数据结构：

- maxSize
- front：指向队首的前一个位置
- rear：直接指向队尾



方法：

- 构造器： `front = rear = -1`
- 判断队列是否满
- 判断队列是否为空
- 入队列
- 出队列
- 队列打印



#### 数组实现（环形）

在数组实现的基础上改成环形数组（取模）



数据结构：

- maxSize
- front：指向第一个元素
- rear：指向最后一个元素的后一个（希望空出一个空间，作为约定）



方法：

- 构造器：`front =0,rear = 0`
- 判断队列是否满：`(rear + 1) mod maxSize == front` 
- 判断队列是否为空：`rear == front`
- 入队列
- 出队列
- **队列打印** ：`rear + maxSize - front) % maxSize`





#### 链表实现







### 4. 栈

数据结构：

- 先进后出 后进先出
- 有栈底指针base和栈顶指针top



#### 数组实现

- top初始化为-1，入栈时 stack[top] = data

- 设定栈的最大容量

  

#### 链表实现

- 头插法
- 不设定最大容量



**实例：**

计算器实现

1. 中缀表达式直接运算，即”6+3*3-1“
   - 运算符的优先级：比较当前要入栈的运算符的优先级于栈顶优先级
     - 若栈为空，则直接入栈
     - 若当前要入栈的优先级更大，则直接入栈
     - 若栈顶优先级更大，则出栈并计算栈顶运算符：数栈中pop两个数，符号栈pop一个符号，将**计算结果入数栈**（每一次计算结果都要入栈），将新符号入符号栈
   - 构造完毕后，从数栈和符号栈中取出并进行运算，最后数栈中的值为最终结果



> 前缀表达式：运算符位于操作数前面，不需要判断优先级
>
> - 先求出前缀表达式
> - 从右到左扫描，遇到数字进栈，遇到字符则弹出两个数字运算
>
> 后缀表达式：运算符位于操作数后面
>
> - 先求出后缀表达式
>
>   <img src="C:\Users\12505\AppData\Roaming\Typora\typora-user-images\image-20210711120754741.png" alt="image-20210711120754741" style="zoom: 50%;" /> 
>
> - 从左到右扫描，遇到数字进栈，遇到字符则弹出两个数字运算



### 5. 哈希表

HashTable：

- 可以根据关键码值而直接进行访问（定位其在表中的位置）
- 将一条链表的查询散在了多条链表中，加快查询速度



出现：

手动实现数据的缓存层（类似Redis），避免程序大量查询数据库消耗大量时间



实现：

- 数组+链表

  - 数据结构：数组+链表+结构体

  <img src="C:\Users\12505\AppData\Roaming\Typora\typora-user-images\image-20210718103218356.png" alt="image-20210718103218356" style="zoom: 50%;" /> 

- 数组+二叉树





## 树形结构

> 数组：
>
> - 下标访问，访问速度快
> - 增加元素困难
> - 实例：
>   - ArrayList底层为Object[]，按比例实现动态扩容
>
> 链表：
>
> - 插入、删除节点效率高，且不需要连续的存储空间
> - 查询访问节点困难
>
> 树：提高整体效率



### 1. 二叉树

以根的访问顺序做划分

左子树始终先于右子树



#### 遍历

- 先序遍历
  - 根左右
    - 先打印当前节点
    - 左节点递归
    - 右节点递归

- 中序遍历
  - 左根右
    - 先左节点递归
    - 打印当前节点
    - 右节点递归

- 后序遍历
  - 左右根
    - 先左节点递归
    - 右节点递归
    - 打印当前节点



#### 查找

- 前序查找
  - 根左右
    - 先判断当前节点
    - 若当前节点没有找到，则递归判断左节点
    - 若左节点没有找到，则递归判断右节点
- 中序查找
  - 左根右
    - 先递归判断左节点
    - 若左节点没有找到，则判断当前节点
    - 若当前节点没有找到，则递归判断右子节点
- 后序查找
  - 左右根
    - 先递归判断左节点
    - 若左节点没有找到，则判断当前节点的右子节点
    - 若右子节点没有找到，则判断当前节点



注意：

- 递归调用是用左/右节点进行递归调用
- 查找和遍历有所不同
  - 遍历无需返回值，且不用关心结果，只需要一直递归直到无法递归（即为空）
  - 查找要关心返回值，即一轮查找没有找到才进行下一轮，若找到了需要及时返回



#### 删除

算法：

- 寻找待删除节点的父节点
- 从父节点删除此子节点
  - 先判断左节点是否为待删除节点
  - 再判断右节点
  - 再循环判断左子树
  - 在循环判断右子树





## 图

