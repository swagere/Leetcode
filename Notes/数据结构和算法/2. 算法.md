## 算法基础

### 1. 时间复杂度

#### 1.1 概念

- 事后统计法
- 事前估算法

时间复杂度规则：常数项、低次项、系数都可忽略，例：T(n) = O(n^2)



#### 1.2 常用时间复杂度

<img src="C:\Users\12505\AppData\Roaming\Typora\typora-user-images\image-20210714145936117.png" alt="image-20210714145936117" style="zoom: 67%;" /> 

注：

- 对数阶

  ```java
  int i = 1;
  while (i < n) {
  	i = i * 2;
  }
  ```

- 线性对数阶（线性+对数）

  ```java
  //线性
  for (int n = 1; n < m; n++) {
      int i = 1;
      //对数
      while (i < n) {
          i = i * 2;
      }
  }
  ```



### 2. 空间复杂度



## 线性结构

### 1. 递归

#### 1.1 递归原理

1. 当程序执行到一个方法/函数时，就在jvm中开辟一个独立的**栈**空间，即递归的底层为栈

   > 新的栈空间创建时：
   >
   > - 将目前EBP（栈底指针）入栈
   > - 移动EBP
   > - 移动ESP，为新函数预分配空间
   > - 压入子函数返回地址
   > - 压入新函数的参数
   > - ？

   <img src="C:\Users\12505\AppData\Roaming\Typora\typora-user-images\image-20210712160851961.png" alt="image-20210712160851961" style="zoom: 50%;" /> 

2. 递归完成后返回，只返回结果而不会返回每次递归调用变化的n

3. 函数的局部变量是独立于自己的栈空间的，不会相互影响，比如n

4. 函数的参数如果是引用类型，则会使用同一个数据空间



#### 1.2 实例

迷宫问题

- 递归回溯实现：最短路径跟设定找路的策略有关（可以遍历所有策略 以找出最短路径）
  - 递归实现
  - 到找到目标之后依次返回
- bfs广搜：只能找到最短路径的值，没有路线
  - 用list/queue存储
  - while循环

八皇后问题

- 递归回溯实现：从不同行不同列开始递归
  - 用一维数组代替二维数组存储每次寻找结果





### 2.排序算法

**分类：**

- 内部排序：在内存中进行
  - 插入
    - 直接插入
    - 希尔
  - 选择
    - 简单选择
    - 堆排序
  - 交换
    - 冒泡排序
    - 快速排序
  - 归并
  - 基数-》统排序
- 外部排序：借助外存中进行，数据量过大，无法全部加载到内存中，需要借助外部存储（文件等）



**整体思想：**

按照某种方法找到每轮循环包含范围内最大/最小的值，并放于正确位置

- 冒泡排序：边找边放
- 选择排序：找完再放



#### 2.1 冒泡排序

算法：以num[n]为例

- 经历n-1轮排序
  - 每轮排序中都是相邻两个元素依次比较，若大小不符合规则 则交换
  - 每一轮排序，就相当于确定目前的轮次的个数中最大的一个数 并放于末尾
- 每轮排序次数依次减1，由n-1减到1
- 时间复杂度：T($n$) = O($[1+(n - 1)]*(n - 1) / 2$)=O($n^2$) 

算法优化：若在某一轮中没有一次交换，则说明已经排序完成



#### 2.2 选择排序

算法：以num[n]为例

- 经历n-1轮排序
  - 每一轮寻找范围内最小的数据，再放在范围内最前面的位置



### 二分查找

target index left right mid

查找/比较中间值

舍弃左边/右边的



### 动态规划

由已知结果得到新结果



