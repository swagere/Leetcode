## 基础

### 1. 时间复杂度

#### 1.1 概念

- 事后统计法
- 事前估算法

时间复杂度规则：常数项、低次项、系数都可忽略，例：T(n) = O(n^2)



#### 1.2 常用时间复杂度

<img src="C:\Users\12505\AppData\Roaming\Typora\typora-user-images\image-20210714145936117.png" alt="image-20210714145936117" style="zoom: 67%;" /> 

注：

- 对数阶

  ```java
  int i = 1;
  while (i < n) {
  	i = i * 2;
  }
  ```

- 线性对数阶（线性+对数）

  ```java
  //线性
  for (int n = 1; n < m; n++) {
      int i = 1;
      //对数
      while (i < n) {
          i = i * 2;
      }
  }
  ```



### 2. 空间复杂度



## 算法

### 1. 递归

#### 1.1 递归原理

1. 当程序执行到一个方法/函数时，就在jvm中开辟一个独立的**栈**空间，即递归的底层为栈

   > 新的栈空间创建时：
   >
   > - 将目前EBP（栈底指针）入栈
   > - 移动EBP
   > - 移动ESP，为新函数预分配空间
   > - 压入子函数返回地址
   > - 压入新函数的参数
   > - ？

   <img src="C:\Users\12505\AppData\Roaming\Typora\typora-user-images\image-20210712160851961.png" alt="image-20210712160851961" style="zoom: 50%;" /> 

   递归完成后返回，只返回结果而不会返回每次递归调用变化的n

3. 函数的局部变量是独立于自己的栈空间的，不会相互影响，比如n

4. 函数的参数如果是引用类型，则会使用同一个数据空间



#### 1.2 实例

迷宫问题

- 递归回溯实现：最短路径跟设定找路的策略有关（可以遍历所有策略 以找出最短路径）
  - 递归实现
  - 到找到目标之后依次返回
- bfs广搜：只能找到最短路径的值，没有路线
  - 用list/queue存储
  - while循环

八皇后问题

- 递归回溯实现：从不同行不同列开始递归
  - 用一维数组代替二维数组存储每次寻找结果





### 2.排序算法

**分类：**

- 内部排序：在内存中进行
  - 插入
    - 直接插入
    - 希尔
  - 选择
    - 简单选择
    - 堆排序
  - 交换
    - 冒泡排序
    - 快速排序
  - 归并
  - 基数=>统排序
- 外部排序：借助外存中进行，数据量过大，无法全部加载到内存中，需要借助外部存储（文件等）

<img src="C:\Users\12505\AppData\Roaming\Typora\typora-user-images\image-20210716153845565.png" alt="image-20210716153845565" style="zoom: 67%;" /> 



**整体思想：**

按照某种方法找到每轮循环包含范围内最大/最小的值，并放于正确位置

- 冒泡排序：找最大的数放末尾，边找边放
- 简单选择排序：找最小的数放开头，找完再放
- 堆排序：构造大顶堆，找最大的数放末尾，找完再放

找到每轮循环中，对应元素的位置并放置（此时不一定是最大/最小值）

- 直接插入排序：边找边插入
- 快速排序：放置范围内中间位置的元素，边找边放



希尔/归并/基数：同时对多个数据进行排序



#### 2.1 冒泡排序

算法：以num[n]为例

- 经历n-1轮排序
  - 每轮排序中都是相邻两个元素依次比较，若大小不符合规则 则交换
  - 每一轮排序，就相当于确定目前的轮次的个数中最大的一个数 并放于末尾
- 每轮排序次数依次减1，由n-1减到1
- 时间复杂度：T($n$) = O($[1+(n - 1)]*(n - 1) / 2$)=O($n^2$) 

算法优化：若在某一轮中没有一次交换，则说明已经排序完成



#### 2.2 快速排序

算法：

- 以中间这个值为基准，分解问题，比基准大的放于右边，比基准小的放于左边（中间值的位置可能会变化），每一部分再重复这个步骤，直到只剩一个数为止
- 递归解决



#### 2.3 简单选择排序

算法：以num[n]为例

- 经历n-1轮排序
  - 每一轮寻找范围内最小的数据，再放在范围内最前面的位置



#### 2.4 直接插入排序

算法：

- 以空表向中间找到其应该放的位置，插入元素来获得有序表
- 经历n-1轮排序（1~n-1）
  - 每轮排序将第i个元素放在前i-1个元素的相应位置
  - 两两交换，直到找到最终位置=>优化为移位：找到位置前其余元素后移，即减少交换次数



#### 2.5 希尔排序

算法：

- 直接插入排序的优化版
  - 从length/2为增量，对一个增量内的数组（每隔增量个元素 为同一增量内的一个数组）进行排序
  - 最后直到增量变为1，即对整个数组进行最后一次排序
  - 两两交换，直到找到最终位置=>优化为移位：找到位置前其余元素后移，即减少交换次数



两种插入排序的区别：

- 直接插入排序
  - 相当于有两个数组，一个为有序数组，一个为无序数组
- 希尔排序
  - 在每轮中，有length/2^n个有序数组，一个无序数组
  - 不以有序数组为序依次放入，而是以无序数组遍历，每次遍历无序数组的一个元素时，利用交换/移位法



#### 2.6 归并排序

算法：使用分治算法（先分再合）

- 分：分到单元素为止
- 治：每两个组合并，合并成有序列
  - 双指针，同时遍历两个组，用新的数列来存储有序数组



#### 2.7 基数排序

算法：桶排序的扩展

- 生成9个数组，分别存储每一轮对应位置相等的元素
- 从个位开始，直到循环到最高位
- 每一轮放完后再按顺序依次取出，进行下一轮



空间换时间



#### 2.8 堆排序

> - 大顶堆
> - 小顶堆

一般升序用大顶堆，降序用小顶堆



算法（以大顶堆为例）：

- 经历n-1轮排序
- 每轮将范围内的数组构造成大顶堆，再把最大的第一个放到范围最后
  - 每轮非叶子节点个数：length/2- 1
  - 类似顺序存储二叉树（层次遍历结果），只是逻辑构建，真实数据结构为数组
  - 构造大顶堆的方法：从后往前找到非叶子节点 比较该非叶子节点和其子节点的大小，选出最大的放在非叶子结点的位置（交换）

### 3. 查找算法

分类：

- 线性/顺序查找
- 二分/折半查找
- 插值查找
- 斐波拉契查找



#### 3.1 线性查找

要求：

- 数组为有序/无序都可



算法：

- 逐一比对，有相同值就返回下标



#### 3.2 二分查找

要求：

- 有序数组



算法：

- target left right mid

- 查找/比较中间值

- 舍弃左边/右边的，left++或者right--
- 使用递归/循环



#### 3.3 插值查找

要求：

- 有序数组



算法：

- 二分查找的优化：线性插值（拉格朗日中值定理），按比例缩放

  <img src="C:\Users\12505\AppData\Roaming\Typora\typora-user-images\image-20210717121746095.png" alt="image-20210717121746095" style="zoom:67%;" /> 

- 适用于数据量较大，分布较均匀的数组，等差数列效果最好
- 不适用于跳跃性太大的数组



#### 3.4 斐波拉契查找

要求：

- 有序数组



算法：

- 斐波拉契数列也满足黄金分割法
- 按照黄金分割的比例划分每次待排序数组，mid值即为黄金分割的值
  - 结合斐波拉契数组实现，用斐波拉契数组实现黄金分割，即寻找mid值





<img src="C:\Users\12505\AppData\Roaming\Typora\typora-user-images\image-20210717144026274.png" alt="image-20210717144026274" style="zoom: 50%;" /> 



### 4. 分治算法

算法步骤：

- 分解
- 解决
- 合并



#### 4.1 汉诺塔问题

算法：假设有三个塔A B C

- 将问题分解为最下面的一个盘和上面的所有盘
  - 移动上面所有盘A->B
  - 移动最下面的盘A->C
  - 移动上面所有盘B->C



### 5. 动态规划

算法步骤：

- 分解
- 解决
- 合并



与分治法区别：

- 分治法
  - 子问题之间相互独立
  - 从上到下解决子问题
- 动态规划
  - 下一个阶段的子问题的解建立在上一个阶段子问题的解的基础上
  - 从下到上解决



#### 5.1 背包问题

算法：将物品分开，将背包容量拆分为1-n

- 每个物品从背包容量1-n填表
  - 如果物品容量>背包现容量，即不能放下物品：继承原来最大价值 $v[i - 1][j]$[][j];
  - 如果物品容量<=背包现容量，即可以放下物品：max(原来最大价值，将物品放入后+剩余容量的最大值) $Math.max(v[i - 1][j], w[j] + v[i - 1][n - w[j]])$



背包问题依赖于前面找到的最优解

每下一行都是目前的最优解



### 6. KMP算法
