## 一、引论

### 1. 计算机系统组成

- 应用程序
- 操作系统
- 硬件



### 2. 操作系统作用

- 为硬件提供资源管理功能
  - 处理机管理
  - 存储器管理
  - 文件管理
  - 设备管理
- 为应用程序提供接口
  - 用户接口
    - 命令接口
    
      > 用户直接使用
    
      - 联机命令接口（交互式）：一句一句的输入和执行
      - 脱机命令接口（批处理）：一段一段的输入和执行
    
    - 程序接口：由一组系统调用组成
    
      > 程序调用，程序直接使用
  - 图形用户界面
  
- 对硬件机器实现拓展



### 3. 操作系统特征

- 并发：

  > 并行：一个时刻可以同时运行多个任务
  >
  > 串行：一个时刻只运行一个任务
  >
  > 并发：宏观上并行，微观上串行 
  >
  > 
  >
  > 单核cpu是串行的，多核CPU可以同时运行的进程数和核数相等

- 共享：系统中的资源可以供多个并发执行的进程共同使用

  - 互斥共享：一个时间段，资源只允许一个进程使用
  - 同时共享：一个**时间段**，资源允许多个进程使用（并发/并行都可能发生，如文件传输/听歌和打游戏）

- 虚拟：

  - 空分复用技术
  - 时分复用技术

- 异步：



### 4. 操作系统发展（b

- 主机完全控制输入输出
- 单道批处理系统
- 多道批处理系统
- 分时系统
- 实时系统



### 5. 操作系统运行机制

#### 5.1 指令

指令：操作系统能识别并执行的最基本的命令



分类：

- 特权指令
- 非特权指令



#### 5.2 处理器状态

- 用户态：CPU只能执行非特权指令
- 核心态：执行特权/非特权指令



用程序状态字寄存器的标志位来标识当前处理机的状态



**转换：**

- 用户态转换到核心态的切换由且只能由中断完成
- 核心态转换为用户态 通过更改程序状态字标志位完成



#### 5.3 程序分类

- 内核程序：运行在核心态，实现**操作系统内核**功能的程序即为内核程序

  > 操作系统内核：运行在操作系统最底层
  >
  > - 时钟管理
  > - 中断处理
  > - 原语
  > - 对系统资源进行管理的功能
  >   - 进程管理
  >   - 存储器管理
  >   - I/O设备管理等
  >
  >  
  >
  > 操作系统体系结构：
  >
  > - 大内核：四个部分都包括
  >
  > - 微内核：只包括前三个部分
  >
  > 

- 应用程序：运行在用户态



### 6. 中断和异常

中断机制诞生于实现多道程序并发运行

本质：发生中断就意味着操作系统要介入，开展管理工作



#### 6.1 中断过程

- 进程向CPU发出中断信号
  - 计时部件发出中断信号
  - 进程发出系统调用（内中断信号）
  - I/O设备发出I/O完成的中断信号
- CPU切换到核心态，把CPU使用权限交给操作系统
- 操作系统内核对中断信号进行处理
  - 时间片用完，切换到下一个进程
  - 操作系统让I/O设备开始工作，并让当前进程暂停，切换到下一个进程
  - 操作系统让上一个进程恢复运行
- 操作系统把CPU使用权限交还给用户进程，另一个进程开始执行



#### 6.2 中断分类

##### 6.2.1 内中断/异常

中断信号的来源为CPU内部，与当前执行的指令有关



分类：

- 自愿/指令中断：如系统调用等
- 强迫中断：
  - 硬件故障：如缺页
  - 软件中断：如整数/0



##### 6.2.2 外中断

中断信号的来源为CPU外部，与当前执行的指令无关



分类：

- 外设请求：如I/O设备完成操作
- 人工干预：如用户强制终止一个进程



### 7. 系统调用

应用程序通过系统调用来请求操作系统的服务

> 防止应用程序可以随意使用系统资源而造成问题



**系统调用和库函数的区别：**

应用程序通过调用库函数 从而完成系统调用

- 库函数相当于是对系统调用的一个封装，但不是所有库函数都进行了系统调用，如读取一个值的绝对值
- 库函数屏蔽掉了系统调用的一些具体细节
- 而系统调用又屏蔽了硬件操作的细节

<img src="..\img\image-20210806185537857.png" alt="image-20210806185537857" style="zoom:50%;" /> 



**系统调用发生过程：**

以程序为例，翻译成机器码后：

- 用户态下：
  - 把参数装入寄存器
  - 发出中断（即系统调用）
- 核心态：
  - 操作系统内核处理中断



即发出系统调用为用户态，处理系统调用为核心态





## 二、进程与线程

### 1. 进程

#### 1.1 进程定义

进程的引出：为了实现多个程序并发执行



#### 1.2 进程的组成

单个进程

- PCB：操作系统用于管理进程的信息，是进程存在的唯一标识
  - 进程描述信息
    - 进程标识符PID
      - 进程创建时 os分配
      - 用来标识进程是独一无二的
    - 用户标识符UID
  - 进程管理和控制信息
  - 资源分配清单
  - 处理机相关信息
- 程序段：存放程序代码
- 数据段：程序运行时使用、产生的运算数据



#### 1.3 进程的组织

多个进程

- 链接方式：按照进程状态分为多个队列
  - 操作系统指针：
    - 执行指针
    - 就绪队列指针
    - 阻塞队列指针
- 索引方式：根据进程状态不同，建立多张索引表，索引表项中存放的是PCB的地址
  - 操作系统指针：
    - 执行指针
    - 就绪表指针
    - 阻塞表指针



#### 1.4 进程特征

- 动态性
- 并发性
- 独立性：进程是资源分配，接受调度的基本单位 
- 异步性：可能会导致执行结果的不确定性
- 结构性



#### 1.5 进程状态

**五种状态：**

- 运行态：占用CPU资源，正在运行的进程
- 就绪态：已经具备运行条件，但CPU未空闲（拥有除处理机外所有的资源，一旦获得处理机，该进程就可以开始执行
- 阻塞态：等待某个事件发生

- 创建态：进程正在被创建，正在被分配资源、初始化等
- 终止态：进程正在撤销，操作系统会回收资源等



**进程状态的转换：**

<img src="..\img\image-20210809215239466.png" alt="image-20210809215239466" style="zoom: 43%;" />  



#### 1.6 进程控制

使用原语实现进程控制->进程控制为原子操作

- 原语：关中断+开中断



原语框架：

- 更新PCB信息
- 将PCB放入队列
- 分配/回收资源



##### 1.6.1 进程控制相关的原语

- 进程创建（无->创建态->就绪态
  - 创建原语：
    - 申请空白PCB
    - 为进程分配资源
    - 初始化PCB
    - 将PCB加入就绪队列
  - 引起进程创建的事件：
    - 用户登陆
    - 作业调度
    - 提供服务
    - 应用请求
- 进程终止（就绪态/运行态/阻塞态->终止态
  - 撤销原语：
    - 找到要终止进程的PCB
    - 若进程正在执行，则剥夺CPU，将CPU分配给其他进程
    - 终止其所有子进程
    - 将该进程拥有的资源还给操作系统或者其父进程
    - 删除PCB
  - 引起进程终止的事件：
    - 正常结束（运行态
    - 异常结束（运行态
    - 外界干预（将就绪态/阻塞态的进程终止

- 进程阻塞（运行态->阻塞态
  - 阻塞原语：
    - 找到要阻塞进程的PCB
    - 保护进程运行线程，改变PCB状态信息，暂时停止CPU运行
    - 将PCB插入相应事件的阻塞队列
  - 引起进程阻塞的事件：
    - 等待系统分配某种资源
    - 等待合作的其他进程完成工作
- 进程唤醒（阻塞态->就绪态
  - 唤醒原语：
    - 找到要唤醒进程的PCB
    - 将PCB从阻塞队列移除，改变PCB状态信息
    - 将PCB加入到就绪队列
  - 引起进程唤醒的事件：
    - 等待事件发生了

- 进程切换（运行态->阻塞态/就绪态；就绪态->运行态
  - 切换原语：
    - 将运行环境存入PCB
    - 将PCB移入相应队列
    - 选择另一个进程执行，更新新进程PCB
    - 根据PCB恢复新进程运行环境
  - 引起进程切换的事件：
    - 当前进程时间片到
    - 有优先级更高的进程到达
    - 当前进程主动阻塞
    - 当前进程终止





#### 1.7 进程通信

即进程间的信息通信



##### 1.7.1 共享存储

多对多

操作系统分配一个共享空间，进程对共享空间的访问是互斥的

- 基于数据结构：如数组等
- 基于存储区：数据的形式、在存储区中的存储位置等都由进程自己协商决定



##### 1.7.2 管道通信

多对一

即在内存空间中开辟的一个大小固定的缓冲区，一般和一个页面大小一致

- 管道采用半双工通信，可以设置两个管道完成双向同时通信
- 进程对管道的访问是互斥的



通信流程：

- 进程A往管道中写数据，调用**write()系统调用**，以字符流的形式写入
- 当管道中数据写满之后，**write()系统调用**被阻塞，进程B才能从管道中读数据，调用**read()系统调用**
- 当管道中全部数据被读出时，**read()系统调用**被阻塞进程A才能写数据



管道中数据一旦被读出，就从管道中被抛弃，故一个管道的读进程只能有一个



##### 1.7.3 消息传递

多对多/一对一

传递的数据为**格式化的消息**，通过原语实现数据交换：发送消息/接收消息

- 消息头
- 消息体



消息传递的两种方式

- 直接通信方式：消息直接挂到接收进程的消息缓冲队列上
- 间接通信方式：消息要先发到信箱上
  - 信箱为操作系统为所有进程维护的交换信息的一个方式
    - 不同的进程都可以把要和其它进程通信的消息发到信箱
    - 要取消息时使用接收原语从信箱中取出



### 2. 线程

#### 2.1 进程定义

增加线程的并发度，即在进程中也实现并发功能



进程：资源分配的基本单位

线程：调度的基本单位



#### 2.2 线程的实现方式

- 用户级线程：从用户视角看到的线程
  - 由应用程序通过线程库实现
  - 所有的线程管理工作都由应用程序负责（包括线程切换
- 内核级线程：从操作系统内核视角能看到的线程
  - 线程管理工作由操作系统内核完成
  - 在核心态下完成
  - **只有内核级线程才是处理机调度的基本单位**



#### 2.3 多线程模型

- 多对一模型：
  - 多个用户级线程映射到一个内核级线程
  - 每个用户进程只对应一个内核级线程
- 一对一模型：即纯粹的内核级线程
  - 一个用户及线程映射到一个内
    核级线程
  - 每个用户进程有与用户级线程同
    数量的内核级线程
- 多对多模型：
  - n用户及线程映射到m个内核级线程(n>=m)
  - 每个用户进程对应m个内核级线程



## 三、处理机调度

即实现并发的功能



### 1. 三个层次

#### 1.1 高级调度

即作业调度

作业->创建态->就绪态



**过程：**

- 按一定的原则从外存上处于后备队列的作业中挑选一个或多个作业
- 分配内存等必要资源，并建立相应的进程(建立PCB)，以获得竞争处理机的权利



#### 1.2 中级调度

即内存调度

挂起就绪态/挂起阻塞态->就绪态/阻塞态

暂时不能运行的进程会调到外存等待（挂起状态）。等其重新具备了运行条件 内存有空闲时，再重新调入内存

PCB一直存在内存中的挂起队列中，不会被调出内存



**过程：**

- 按一定的原则将挂起态的就绪进程调回内存



> 七状态模型：
>
> <img src="../img/image-20210817205151462.png" alt="image-20210817205151462" style="zoom:35%;" /> 



#### 1.3 低级调度

即进程调度

就绪态->运行态



**过程：**

- 按一定的原则将某个进程从就绪态变为运行态



### 2. 进程调度

#### 2.1 进程调度的时机

**可以发生进程调度的时机：**

- 当前运行的进程主动放弃处理机
  - 进程正常终止
  - 进程异常终止
  - 进程主动请求阻塞，如等待I/O等

- 当前运行的进程被动放弃处理机
  - 时间片用完
  - 更紧急的事情要处理，如I/O中断
  - 优先级更高的进程进入就绪队列



**不能发生进程调度的时机：**

- 处理中断时（与硬件密切相关

- 进程在**操作系统内核程序临界区**中

  - 临界资源：互斥访问的资源，一次只允许一个进程使用

  - **临界区**：访问临界资源的那段代码

    > 普通的临界区访问允许进程调度

  - **内核程序临界区**：一般是用来访问某种内核数据结构的，如进程的就绪队列

    - 进程在处于内核程序临界区前，会将临界资源上锁，如果上锁的时就绪队列，那么进程调度将无法正常进行

- 原子操作时（如1.6进程控制中的原语



#### 2.2 进程调度的方式

##### 2.2.1 非剥夺调度方式

即非抢占式，不允许被动放弃处理机

只适合早期的批处理系统



##### 2.2.2 剥夺调度方式

即抢占式，允许被动放弃处理机

适合于分时操作系统，实时操作系统



#### 2.3 进程调度的过程

- 选择一个进程
- 进程切换
  - 保存当前进程的各种数据
  - 恢复新进程的各种数据



### 3. 调度算法

#### 3.1 调度算法评价指标

- CPU利用率：CPU忙碌时间/总时间
- 系统吞吐量：单位时间完成作业的数量 作业数/时间
- 周转
  - 周转时间：作业从提交到完成的时间 完成时间-提交时间
  - 平均周转时间：各作业周转时间和/作业数量
  - 带权周转时间：作业周转时间/作业实际运行时间
  - 平均带权周转时间：各作业带权周转时间和/作业数量
- 等待
  - 等待时间
    - 进程等待时间：建立进程后，等待被服务的时间之和
    - 作业等待时间：进程等待时间+在后备队列中等待的时间
  - 平均等待时间
- 响应时间：用户提交请求到首次产生响应的时间



#### 3.2 批处理系统调度算法

##### 3.2.1 FCFS

即先来先服务，按照到达的先后顺序依次进行调度



**特点：**

- 用于作业调度/进程调度

- 非抢占算法
- 不会导致饥饿



##### 2.4.3 SJF/SPF

即短作业/短进程优先，即最短的最先得到服务



**特点：**

- 用于作业调度SJF/进程调度SPF

- 非抢占算法

  > 抢占版本：**SRTN** 短剩余时间优先算法
  >
  > 
  >
  > 每当有进程进入时，都会检测是否当前运行的进程是否会被抢占（即比较谁的剩余时间更短

- 可能导致饥饿



##### 3.2.3 HRRN

即高响应比优先，每次调度时计算响应比，选择响应比最高的服务

- 响应比 = （等待时间 + 服务时间）/服务时间​



**特点：**

- 用于作业调度/进程调度
- 非抢占式算法
- 不会导致饥饿



#### 3.3 交互式系统调度算法

##### 3.3.1 时间片轮转RR

按照到达的顺序，轮流让各个进程执行一个时间片



**特点：**

- 用于进程调度
  - 时间片是指处理机的时间片
  - 只有作业放入内存变成进程后，才能被分配处理机时间片
- 抢占式算法（由时钟装置发出中断来通知CPU时间到
- 不会导致饥饿
- 常用于分时操作系统



时间片太大时，RR会退化为先来先服务算法



##### 3.3.2 优先级调度

加入了优先级



**特点：**

- 用于作业调度/进程调度
- 抢占/非抢占式算法

- 常用于实时系统
- 会导致饥饿问题



**优先级：**

- 静态/动态优先级
- 静态设计优先级原则：
  - 系统进程>用户进程
  - 前台进程>后台进程
  - I/O型进程>计算型进程
    - I/O设备和CPU可以并行工作
    - 如果优先让I/0繁忙型进程优先运行的话，则越有可能让I/O设备尽早地投入工作，尽早开始于CPU并行地工作
- 动态调整优先级
  - 等待时间过长 可以提升优先级（类似高响应比优先算法
  - 占用处理机时间过长 可以降低优先级



##### 3.3.3 多级反馈队列调度



**特点：**

- 用于进程调度
- 抢占式算法
- 可能发生饥饿



**流程：**

<img src="../img/image-20210821203326262.png" alt="image-20210821203326262" style="zoom: 50%;" /> 





### 4. 进程同步与互斥

#### 4.1 进程同步

即进程间的直接制约关系，进程间为合作关系，需要协调进程的工作次序



#### 4.2 进程互斥

即进程间的间接制约关系，他们之间并没有直接的关系，是因为临界资源才产生的关系



**流程：**

- 进入区：检查是否可以进入临界区，如果可以进入则对邻接资源上锁
- 临界区：访问临界资源的代码
- 退出区：对临界资源解锁
- 剩余区：其他处理



**原则：**

- 空闲让进
- 忙则等待
- 有限等待（即不会发生饥饿
- 让权等待：即不能进入临界区时，应立即释放处理机，防止占着处理机等待





## 四、内存





## 五、文件





## 六、I/O设备
